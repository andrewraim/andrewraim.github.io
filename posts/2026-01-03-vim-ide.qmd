---
title: "Using Vim as a Simple IDE without Plugins"
date: 2026-01-03
categories:
  - programming
number-sections: true
draft: true
---

<!--
TBD

How about a video or two?

Start in an R script, launch a console, run a few lines, run a block line-by-
line, and run a block that ends somewhere not at the end of a line.

termtosvg would work well, except it doesn't show keystrokes...
-->

# Introduction

There are a vast number of options for text editors, but one compelling reason
to stick with the classic Vim is that it is included with many Unix-based
operating systems such as Linux. It is free and open source, and available
almost everywhere. Despite its humble appearance, is a powerful tool with
extensive features and it can be heavily customized.

In this post, we demonstrate some configuration changes that will let us use
Vim as a simple IDE, without the need for any additional plugins. Here, one
window can be used to edit and run code and a second window can be running an
interpreter. As edit the code, we can send chunks over to the interpreter to
run with a few keystrokes. We will also set make it easy to launch the
interpreter when we are editing a file.

A file with the completed configuration is given
[here](2026-01-03-vim-ide.vim). The easiest way to use it is to paste the
contents into your own [vimrc][h-vimrc] file; however, it is also possible to
use a more modular configuration with multiple files.

[h-vimrc]: https://vimhelp.org/usr_05.txt.html#05.1

::: {.callout-caution title="Vimscript"}
The code shown in this post is written in the Vimscript scripting language. I
am not very familiar with Vimscript and had some help from AI and various forum
posts to get things working. Therefore, it is not the most elegant code and
there are opportunities for improvement.
:::

# Embedded Terminal

We first note that Vim has its own internal terminal. We will make use of this
to run an intrepreter for our language(s) of choice. To start a terminal from
Vim, enter `:term` from normal mode. This starts the terminal in a horizontal
split. See the documentation on [windows][h-windows] on how to change focus
between windows, change their positions, resize them, etc. Exiting the terminal
closes the split. We can also start a terminal with a vertical split using
`:vert term` from normal mode.

Suppose we have a vertical split with an R script on the left and a terminal
running the R console on the right. We would like to be able to send text from
the editor to be execute in the R console without too many keystrokes. We would
also like the ability to quickly spawn that R console when we are working on
an R script.

We will now define two functions.

# Send Text to the Terminal

The first takes a string `content` and sends it to the terminal. There may be
multiple terminals; in this simple implementation (and because I have never
used more than one terminal in the same session), we will always send to the
first one.

```{.vim code-line-numbers="true"}
function! SendToTerm(content)
	let tl = term_list()
	if len(tl) == 0
		echom "No terminal buffer found"
		return
	endif

	let term_buf_nr = tl[0]
	if bufexists(term_buf_nr) && getbufvar(term_buf_nr, '&buftype') ==# 'terminal'
		call term_sendkeys(term_buf_nr, a:content)
	else
		echom "No terminal buffer found"
	endif
endfunction
```

# Spawn a Terminal

The second function spawns a terminal with a suitable interpreter based on the
type of file we are currently editing. If we don't have a specific interpreter
in mind, we will still spawn the terminal and just leave it on the command
line. The function takes a boolean argument `vert`; the terminal will be
started with a vertical split if `vert` is true, otherwise a horizontal split
will be used. After the terminal is spawned, we exchange positions with the
previous window. In vertical mode, this puts the script on the left and the
terminal on the right. In horizontal mode, the script will be on top and the
terminal will be underneath. Also, this will shift the focus back to the script
so that we can start stepping through it.

```{.vim code-line-numbers="true"}
function! FileTypeToTerm(vert)
	if &filetype == 'r'
		let cmd = "R\n"
	elseif &filetype == 'julia'
		let cmd = "julia\n"
	elseif &filetype == 'python'
		let cmd = "python\n"
	else
		let cmd = ""
	endif

	if a:vert
		execute "vertical terminal! " . cmd
	else
		execute "terminal! " . cmd
	endif

	execute "normal! \<c-w>x"
endfunction
```

I have defined interpreters for three specific languages. Of course, you can
add your own filetypes and commands as additional cases. To see the filetype
of a certain script, open the file and run `:echo(&filetype)` in normal mode.
Also note that when `cmd` is a non-empty command, the terminal will halt when
the command exits. However, it will remain open in the halted state until we
exit (e.g., via `:q`). This allows us to note any error messages from our code
that may have crashed the console.

# Bindings

We will set several keybindings to interact with our functions. First, let us
define the leader key, assuming it has not been defined already. A space is
commonly used for this purpose.

```{.vim code-line-numbers="true"}
let mapleader = " "
```

The following to send content from a script to the console.

```{.vim code-line-numbers="true"}
nnoremap <silent> <leader><leader> :call SendToTerm(getline('.')."\n")<cr>g$/\S<cr>:nohl<cr>
xnoremap <expr> <leader><leader> mode() ==# 'V' ?
\ 'y :<c-u>call SendToTerm(@")<cr>`>' :
\ 'y :<c-u>call SendToTerm(@")<cr>`>:<c-u>call SendToTerm("\n")<cr>`<esc>'
```

The `nnoremap` binding is used in normal mode. It sends the current line under
the cursor to the console and moves cursor to the next non-whitespace character
after the line. This allows use to type `<space><space>` repeatedly to step
through the script and run commands line-by-line. Note that `:nohl` is used to
suppress highlighting when we search for `/S` which is the next non-whitespace
character.

The `xnoremap` binding handles two distinct cases. The first case handles
[visual line mode][h-visual-start], where entire lines are selected at a time.
Here we send the entire select (which already includes a newline at the end) to
the console, then move the cursor at the end of the selection. Note that
`<backtick>` then `>` jumps the end of the last selection.  The second case
handles regular visual mode which is character-by-character.  Here the select
does not necessarily end with a newline, so we explicitly send a newline at the
end. To use these bindinds, we highlight text in visual mode and type
`<space><space>` to send it to the console.


The next set of keybindings initializes our console: `<space>th` opens a
console with a horizontal split and `<space>tv` opens a console with a vertical
split.

```{.vim code-line-numbers="true"}
nnoremap <silent> <leader>th :call FileTypeToTerm(v:false)<cr>
nnoremap <silent> <leader>tv :call FileTypeToTerm(v:true)<cr>
```

[h-windows]: https://vimhelp.org/windows.txt.html
[h-visual-start]: https://vimhelp.org/visual.txt.html#visual-start

